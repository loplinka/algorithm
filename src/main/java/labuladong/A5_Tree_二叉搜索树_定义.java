/**
 * Hailiang.com Inc.
 * Copyright (c) 2004-2023 All Rights Reserved.
 */
package labuladong;

/**
 * @author Baojiang Yang
 * @version 二叉搜索树: A5_Tree_二叉搜索树.java, v 0.1 2023年10月19日 00:29  Baojiang Yang Exp $
 */
public class A5_Tree_二叉搜索树_定义 {

    /**
     *
     * 二叉搜索树BST
     * 定义:
     * 1.对于每个节点,左子树的所有节点的值都比它小,右子树的所有节点的值都比它大
     * 2.注意是每个节点,不仅仅是根节点,也就是每个子树都是二叉搜索树
     *
     * 特性:
     * 1.中序遍历的结果是有序的(中序遍历是先遍历做左边,再准备转入到右边遍历,也就是根节点在最中间,则根节点左边小右边大,当然就是有序的)
     * 2.最左侧最小叶子节点的值是最小值
     * 3.最右侧最大叶子节点的值是最大值
     *
     * 适用
     * 1.Java中的TreeMap, TreeSet底层都是BST,只不过是更高级的BST,比如红黑树树(自平衡的BST,自平衡实现非常复杂,无需掌握)
     * 2.TreeMap和TreeSet的Key和Val都存储在节点内,所以搜索起来非常快
     *
     * 数据结构的使命
     * 1.高效的增伤查改
     * 2.其实就是遍历+访问
     *
     * 考察
     * 1.因为BST遍历非常快,所以我们要思考一个题目的解法如何使用快速查找这个特性,进行题目转化
     *
     * 思考:
     * 1.BST的增伤查改的时间复杂度是多少? O(logN)
     * 2.它有什么缺点,如何解决? 如果是一个链表,那么BST就会退化成链表,时间复杂度就会退化成O(N),所以需要平衡二叉树
     *
     */
}